# Теглови соц. купчини (weight-biased leftist heaps)

### В текста по-надолу навсякъде под heap имаме предвид минимален heap, т.е. такъв в който наредбата е `<`.

## Описание на структурата

Leftist heap-овете са структура данни, използваща се най-често като приоритетна опашка.

Като такива, те поддържат ("бързо") операциите за намиране (`findMin`), изтриване на най-малък елемент (`delMin`), както и вмъкване (`insert`) на нов елемент.

По-специалното в интърфейса на leftist heap-овете, е това че те поддържат и бърза операция за сливане (`merge`).

За да се постигнат тези неща, те имат по-различни свойства и инварианти, от тези които са традиционно асоциирани с бинарните heap-ове.

Започвайки от нулата:

### Дефиниции
`Leftist heap` ще наричаме двоично дърво, за което са изпълнени две свойства:

0. "Свойството за наредбата" - стойността на всеки връх от дървото е по-малка от тази на стойностите в децата му.
1. "Свойството на leftist heap-а" (нататък за по-кратко "ранг свойството") - За всяко "ляво дете", **рангът** му е **по-голям или равен** на съответното "дясно дете".

**Ранг** е някаква мярка (начин да даваме числова стойност) на върхове/дървета.

Примери за такива са, "дължината от върха до най-близкото листо", или пък "дължината от върха до най-дясното листо".

В нашия случай, ще използваме мярката "брой на върхове в дървото", просто защото това ще ни е по-лесно за доказване на коректност (това е така, защото с тази мярка е много по-лесно да се определи какъв ще е рангът на резултата от операцията "сливане").

Малко по-формално дефинираният ранг за нашия случай:

0. "Ранг" на празно дърво е `0`. `rank empty = 0`
1. "Ранг" на връх с деца `l` и `r` е с едно повече от сбора на ранговете на `l` и `r`. `rank (node l r) = suc (rank l + rank r)`

Изборът на този ранг, кобминирано с "ранг свойството", гарантират че най-десният път през heap-а е с някаква логаритмична дължина по броя на елементите в heap-а (ако се интересувате може да ми пишете).

Това ни е полезно, защото както ще видим след малко, сложността на сливането (а оттам и на всички други операции) е същата като гореспоменатата дължина.

За да се постигнат желаните сложности, пазаим ранговете ни във върховете, вместо да ги пресмятаме всеки път, за да не обхождаме излишно дървото. Оказва се че лесно можем и да обновяваме ранговете, когато извършваме нужните ни операции.

## Задачи

За да се запознаете със структурата и операциите ѝ, ще ви дам нейна имплементация на `Agda`, в която няма никакви гаранции
в типовата система, за дали са изпълнени нужните свойства от дефиницията горе.

Вашата задача след това ще е да имплементирате сами
* структурата, но с гаранция че е изпълнено свойството за наредбата
* структурата, но с гаранция че е изпълнено свойството за ранга
* структурата, но с гаранция че са изпълнени свойствоот за наредбата и свойството за ранга (което ще означава че формално вече наистина можем да наричаме структурата "weight-biased leftist heap"

### `Common.agda`

Във файла `Common.agda` са отделени някакви "общи" функции и типове, които са нужни за повечето имплементации.

Някои от тях съм написал аз, а някои ви е оставено на вас да направите:

#### `Leq` и свойства
Срещали сме този тип вече на лекции - "по-малко или равно", но в пресметантия си вариант, а не като тип данни.


#### `Priority` и `Rank`
Типови синоними над `Nat` за наше удобство.

`Rank` ще използваме когато говорим за гореспоменатите рангове, докато `Priority` ще наричаме стойностите които вмъкваме в heap-а.


#### `min` и свойства
Традиционната функция, която връща по-малкия от два елемента. Тези неща ви оставям на вас да имплементирате.

Те са нужни само за имплементациите които имат повече гаранции за свойствата.

### Имплементация без инварианти

Имплементацията можете да разгледате и в `Agda`, във файла `Untyped.agda`.

As usual, започваме с дефиницията на данните ни:
```agda
data Heap : Set where
  empty : Heap
  node : Rank -> Priority -> Heap -> Heap -> Heap
```

Както виждате, няма никакви параметри нито типови индекси и ни се налага да пазим рангове във върховете.

За да натъртим това, че тази структура не ни гарантира нищо, ще покажем първо няколко неща които **не са** weight-biased leftist heap-ове.

```agda
-- note how 2 is not < 0
wrongOrder : Heap
wrongOrder = node 2 2 (node 1 0 empty empty) empty

-- note how the rank assigned here is just wrong
wrongRank : Heap
wrongRank = node 1337 0 empty empty

-- note how the left empty has a lower rank than the right node
wrongRankprop : Heap
wrongRankprop = node 2 0 empty (node 1 5 empty empty)
```

И едно, което наистина е.
```agda
-- for the ordering
-- 1 <= 2
-- 1 <= 3
-- also, the ranks are correct, since 3 = 1 + (1 + 1)
-- and the rank property is preserved, since
-- 1 (rank of the right tree) <= 1 (rank of the left tree)
proper : Heap
proper = node 3 1 (node 1 2 empty empty) (node 1 3 empty empty)
```

Първо, нека си направим удобна функция за изваждане на ранга на дърво.

```agda
rank : Heap -> Rank
rank empty = 0
rank (node r _ _ _) = r
```

Целта ни сега е да имплементираме основната операция за сливане на два heap-а.
Идеята с която ще действаме е следната (тя също така е и добре описана в `Purely Functional Data
Structures` нa `Chris Okasaki` - отново, свържете се с мен):

0. Знаем че всичките пътища през heap-а ни са "сортирани", благодарение на свойството за наредбата.
1. В частен случай, това важи и за най-десният път през heap-а.
2. Взимайки два heap-а, можем да слеем най-десните им пътища, запазвайки наредеността - това е много подобно на какво правим когато искаме да слеем два наредени списъка (например при merge sort).
3. Единственото нещо което ни остава е да запазим свойството за ранга. Това ще правим, като допълнително след рекурсивното ни сливане, се грижим да го закърпим, гледайки ранга на резултата от рекурсивното сливане.

Конкретно, имаме "smart constructor" функция(`mkNode`), която по произволен връх и два heap-а, строи нов, за който е изпълнено ранг свойството:
```agda
mkNode : Priority -> Heap -> Heap -> Heap
mkNode x h1 h2 with decLeq (rank h1) (rank h2)
... | inl rankh1<=rankh2
  = node (suc (rank h2 +N rank h1)) x h2 h1
... | inr rankh2<=rankh1
  = node (suc (rank h1 +N rank h2)) x h1 h2
```

Нея ще използваме за "закърпване" на резултат от рекурсивното викане на сливането.

И самото сливане(`merge`):
```agda
{-# TERMINATING #-}
merge : Heap -> Heap -> Heap
merge empty h2 = h2
merge h1 empty = h1
merge h1@(node rank1 x1 l1 r1) h2@(node rank2 x2 l2 r2) with decLeq x1 x2
... | inl x1<=x2
  = mkNode x1 l1 (merge r1 h2)
... | inr x2<=x1
  = mkNode x2 l2 (merge r2 h1)
```

**Бележка за `{-# TERMINATING #-}`**:

Termination checker-ът на `Agda`(2.6.1) не вижда че горната дефиниция е винаги завършваща.
Има начини това да му се покаже наистина, но за да не се занимаваме с "излишни" неща, може просто да ми повярвате за това,
а пък след това да кажем и на termination checker-а да ни "повярва" с прагмата `{-# TERMINATING #-}`.

-- TODO questionable explanation...
Важното да отбележим тук е, че "свойството на наредеността" е запазено, защото избираме по-малката стойност от двата върха,
както и съответното ляво дете, което се грижи лявото дете да е по-малко от върха. Това, дясното дете също да е по-малко,
се запазва "по индукция", от рекурсивното извикване.

След това, както обсъдихме и преди, извикваме `mkNode` за да оправим ранг свойството, като `mkNode` също така и запазва
свойството за наредеността, защото то не прави друго освен най-много да смени лявото и дясното дете.

Имайки вече тази операция, всичко останало става изключително лесно. Вкарването на елемент в heap е същото като да направим
"единичен" heap от елемента и да го слеем с вече съществуващия ни:
```agda
singleton : Priority -> Heap
singleton x = node 1 x empty empty

insert : Priority -> Heap -> Heap
insert x h = merge (singleton x) h
```

Намирането и триенето на минималния елемент са частични операции, защото може heap-ът да ни е празен.

Това може инцидентно да бъде коригирано, когато сложим информация за ранга в типа ни, защото тогава можем да изискваме
да имаме непразен heap.

Намирането е тривиално - това е просто елементът в корена, а пък триенето също става много лесно,
защото можем да слеем двете под-heap-а, които имаме:
```agda
findMin : Heap -> Maybe Priority
findMin empty = no
findMin (node _ x _ _) = yes x

delMin : Heap -> Maybe Heap
delMin empty = no
delMin (node rank x l r) = yes (merge l r)
```

### `Ordered`

Във файла `Ordered.agda` ще намерите скелет, който да попълните.
Тук се очаква, да направите `Heap` типа наподобяващ този от `Untyped.agda`, но така че по конструкция да е изпълнено
свойството за наредеността.

За вдъхновение може да погледнете какво сме правили при наредените списъци и дървета, като адаптирате
идея подобна на тяхната за това как са наредени heap-овете попринцип.

Задачите ви са:

0. Дефинирайте типа, както разказах току-що.
1. Дайте пример за `Heap`, който изпълнява и свойството за ранга.
2. Дайте пример за `Heap`, който има грешен ранг.
3. Дайте пример за `Heap`, който **не изпълнява** свойството за ранга.
4. Имплементирайте `rank`, `mkNode`, `merge`.
5. Имплементирайте `singleton`, `weakenHeap`, `insert`. Ще трябва да помислите и какви типове да дадете за някои от тях.

    `weakenHeap` ще ни е нужно за `insert`. Идеята там вече сте я виждали - разширяваме долната граница на `Heap`-а ни, подобно
    на това което правим при `Fin`-ове, например. Освен `weakenHeap`, може да ви се наложи да доказвате и разни свойства за `min` и `Leq`.

6. Имплементирайте `findMin` и `delMin`.

    За `delMin` можете да си изберете дали да дадете "по-прецизен" тип или "по-груб тип", като по-грубият тип е по-лесен за имплементация, докато "по-прецизният" носи повече информация, но ще изисква повече труд.

### `Ranked`

Във файла `Ranked.agda` ще намерите скелет, който да попълните.
Тук се очаква, да направите `Heap` типа наподобяващ този от `Untyped.agda`, но така че по конструкция да е изпълнено
свойството за ранга.

Тук не мога да ви дам вдъхновение - ще трябва да помислите как да изразите нещата които "знаем" за ранга и дефиницията му чрез типовата система и типови индекси.

Задачите ви са:

0. Дефинирайте типа, както разказах току-що.
1. Дайте пример за `Heap`, който изпълнява и свойството за наредеността.
2. Дайте пример за `Heap`, който **не изпълнява** свойството за наредеността.
3. Имплементирайте `rank`, `mkNode`, `merge`. Ще трябва да помислите и какви типове да дадете за някои от тях.

    Тук най-вероятно ще ви се наложи да се заиграете с `rewrite`-ове и свойства свързани с естествени числа.

    Също така, ще ви е нужно да използвате имплицитните аргументи за ранговете, които вероятно имате в типа си,
    както и в дефинициите на функциите.

4. Имплементирайте `singleton`, `insert`. Ще трябва да помислите и какви типове да дадете за някои от тях.

5. Имплементирайте `findMin` и `delMin`. Помислете какви типове да дадете, така че да не са частични функциите (да не връщат `Maybe Priority`).

### `Full`

Във файла `Ranked.agda` ще намерите скелет, който да попълните.
Тук се очаква, да комбинирате каквото сте направили от `Ordered` и `Ranked`, за да получите нещо което изпълнява по конструкция
и свойството за наредеността и свойството за ранга.

Ако сте си имплементирали функциите и типовете както трябва досега, би трябвало това да е "механична работа" за как да комбинирате двете дефиниции и имплементации.

Задачите ви са:

0. Дефинирайте типа, както разказах току-що.
1. Дайте пример за `Heap`, който изпълнява свойството за наредеността и свойството за ранга.
2. Пробвайте се да дадете пример за `Heap`, който чупи което и да е от двете свойства (не трябва да е възможно!).
3. Имплементирайте `rank`, `mkNode`, `merge`.

    Коментарите от горните две дефниици важат тук.

4. Имплементирайте `singleton`, `weakenHeap`, `insert`.

    Коментарите от горните две дефниици важат тук.

5. Имплементирайте `findMin` и `delMin`.

    Коментарите от горните две дефниици важат тук.

6. Имплементирайте `minimum` и `fromList`

    `minimum` и `length` ще са ви нужни за да дефинирате типа на `fromList`.
